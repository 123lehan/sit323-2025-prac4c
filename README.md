I successfully Dockerized the Calculator API by following a structured approach. Initially, I created a Dockerfile in the root directory of the project, which set up the Node.js environment, copied the necessary project files, installed the required dependencies using npm, and exposed port 3000 for the API. Additionally, I created a docker-compose.yml file to simplify container management, ensuring that the container ran in detached mode and the correct port mappings were set. After building the Docker image using docker-compose up --build -d, I verified the applicationâ€™s functionality by testing the API endpoints (addition, subtraction, multiplication, etc.) in the browser . Once confirmed, I pushed the Docker image to Docker Hub, making it publicly accessible. Finally, I committed all the changes, including the Docker configuration files (Dockerfile and docker-compose.yml), to a GitHub repository, ensuring that the project was version-controlled and shareable. This Dockerization process ensures the Calculator API is portable and can run consistently across any environment with Docker, facilitating easy deployment and collaboration.


I built this Calculator Microservice using Node.js and Express, allowing users to perform basic arithmetic operations like addition, subtraction, multiplication, and division, along with more advanced operations such as exponentiation, square root, and modulo. The microservice is designed to handle HTTP GET requests where users provide numbers as query parameters (e.g., num1 and num2), and I return the results of the requested operation.
To ensure a smooth experience, I incorporated robust error handling that checks for invalid inputs like missing or non-numeric values. If there's an issue with the request, I return meaningful error messages and appropriate HTTP status codes (e.g., 400 for bad requests, 404 for unsupported operations, and 500 for server errors).
Each operation (addition, subtraction, multiplication, division, exponentiation, square root, and modulo) has its own dedicated route with validation checks. The service is accessible via http://localhost:3000, and you can test it using directly in a browser.
Additionally, I added a global error handler to catch unexpected issues, log them, and provide a generic error message. This microservice showcases simple REST API design while ensuring that users have a seamless and reliable experience, even when errors occur.
